# Tailscale 智能代理转发服务 - 完整设计方案

## 1. 完整系统架构
```mermaid
graph TD
    %% 客户端层
    A[客户端应用] --> B{请求类型}
    B -->|代理请求| C[HTTP/HTTPS 代理:8081]
    B -->|代理请求| D[SOCKS5 代理:1080]
    B -->|管理请求| E[管理 API:9091]
    
    %% 服务层
    C --> F[Go 转发服务核心]
    D --> F
    E --> G[节点注册管理器]
    
    %% 管理功能
    G --> H[注册 API 处理器]
    H --> I[headscale 命令执行]
    I --> J[headscale nodes register<br/>--key XXX]
    
    %% 数据管理层
    F --> K[智能缓存管理器]
    K --> L[设备类型过滤器]
    K --> M[节点状态监控器]
    K --> N[(动态节点缓存<br/>内存存储)]
    
    %% 外部服务集成
    L --> O[Headscale gRPC API:50443]
    M --> P[Headscale HTTP API:8080]
    F --> Q[Tailscale Socket 通信]
    Q --> R[/var/run/tailscale/tailscaled.sock]
    
    %% 定时任务
    S[定时任务调度器] --> T[缓存更新任务<br/>每 5 秒]
    S --> U[状态检查任务<br/>每 10 秒]
    T --> O
    U --> P
    
    %% 节点池
    F --> W[Android 节点池]
    W --> X[节点1: http://ip1:port]
    W --> Y[节点2: http://ip2:port]
    W --> Z[节点N: http://ipN:port]
    
    %% 状态管理
    M --> AA{节点状态检查}
    AA -->|在线| BB[保持在缓存]
    AA -->|离线| CC[从缓存移除]
    
    %% 设备过滤
    L --> DD{设备类型检查}
    DD -->|Android| EE[✓ 加入缓存]
    DD -->|iOS| FF[✗ 忽略设备]
    
    %% 外部容器服务
    J --> GG[headscale 容器]
    R --> HH[tailscale 容器]
    
    style F fill:#e1f5fe
    style G fill:#f3e5f5
    style K fill:#fff3e0
    style N fill:#e8f5e8
    style S fill:#fce4ec
```


## 2. 完整交互流程
```mermaid
sequenceDiagram
    participant Admin as 管理员
    participant API as 转发服务 API
    participant Register as 注册管理器
    participant Monitor as 状态监控器
    participant Cache as 智能缓存
    participant Headscale as Headscale 服务
    participant Socket as Tailscale Socket
    participant Client as 代理客户端
    participant Android as Android 节点

    Note over API: 系统启动初始化
    API->>Headscale: 获取现有节点列表
    Headscale-->>API: 返回所有已注册节点
    API->>Cache: 过滤 Android 设备并建立初始缓存
    API->>Monitor: 启动状态监控服务
    
    Note over Monitor: 定时任务启动
    loop 每 5 秒执行
        Monitor->>Headscale: 刷新节点列表
        Headscale-->>Monitor: 返回最新节点信息
        Monitor->>Cache: 更新 Android 节点缓存
    end
    
    loop 每 10 秒执行
        Monitor->>Headscale: 检查节点在线状态
        Headscale-->>Monitor: 返回节点状态
        alt 发现离线节点
            Monitor->>Cache: 移除离线 Android 节点
        end
    end
    
    Note over Admin: 动态节点注册流程
    Admin->>API: POST /api/v1/register<br/>{key: "D5D0R2gwvodpIKhEyZ4lrFVO"}
    API->>Register: 处理注册请求
    Register->>Headscale: headscale nodes register --key XXX
    Headscale-->>Register: 返回注册结果和节点信息
    
    Register->>Register: 检查设备类型
    alt 设备是 Android
        Register->>Cache: 添加到活跃节点缓存
        Register->>Monitor: 开始监控新节点
        Register-->>API: 注册成功，已加入代理池
    else 设备是 iOS
        Register-->>API: 注册成功，但已忽略 (iOS)
    end
    
    Note over Client: 代理服务使用流程
    Client->>API: HTTP/HTTPS 代理请求
    API->>Cache: 查询可用 Android 节点
    Cache-->>API: 返回在线节点列表
    API->>API: 负载均衡选择最优节点
    
    API->>Socket: 通过 tailscale 建立连接
    Socket-->>API: 网络连接就绪
    API->>Android: 转发请求到 http://ip:port
    Android-->>API: 返回目标响应
    API-->>Client: 转发响应给客户端
    
    Note over Client: SOCKS5 代理使用
    Client->>API: SOCKS5 连接请求
    API->>Cache: 获取可用节点
    API->>API: 建立 SOCKS5 隧道
    API->>Android: 通过隧道转发流量
    Android-->>Client: 直接响应流量
    
    Note over Monitor: 故障恢复流程
    Monitor->>Android: 健康检查失败
    Monitor->>Cache: 标记节点为不可用
    Monitor->>API: 通知负载均衡器更新
    
    alt 节点恢复在线
        Monitor->>Android: 健康检查成功
        Monitor->>Cache: 恢复节点可用状态
    end
 ```

## 3. 技术模块详细设计
```mermaid
flowchart TB
    A[main.go] --> B[应用程序启动器]
    
    B --> C[配置管理模块]
    C --> C1[配置文件解析]
    C --> C2[环境变量处理]
    C --> C3[默认值设置]
    
    B --> D[HTTP 服务器模块]
    D --> D1[代理服务路由]
    D --> D2[管理 API 路由]
    D --> D3[健康检查路由]
    D --> D4[中间件处理]
    
    B --> E[节点注册管理模块]
    E --> E1[注册请求处理器]
    E --> E2[Headscale 命令执行器]
    E --> E3[设备类型识别器]
    E --> E4[注册结果验证器]
    
    B --> F[智能缓存管理模块]
    F --> F1[内存缓存存储]
    F --> F2[并发安全读写]
    F --> F3[节点生命周期管理]
    F --> F4[缓存清理策略]
    
    B --> G[状态监控模块]
    G --> G1[定时任务调度器]
    G --> G2[节点状态检查器]
    G --> G3[健康检查执行器]
    G --> G4[故障恢复处理器]
    
    B --> H[代理服务模块]
    H --> H1[HTTP 代理服务器]
    H --> H2[SOCKS5 代理服务器]
    H --> H3[请求转发处理器]
    H --> H4[响应流处理器]
    
    B --> J[外部集成模块]
    J --> J1[Headscale gRPC 客户端]
    J --> J2[Headscale HTTP 客户端]
    J --> J3[Tailscale Socket 客户端]
    J --> J4[IPN 消息处理器]
    
    %% 模块间依赖关系
    E1 -.-> J2
    E2 -.-> J1
    F1 -.-> G2
    G3 -.-> J1
    H3 -.-> J3
    
    style A fill:#ff9999
    style D fill:#ffcc99
    style E fill:#99ff99
    style F fill:#99ccff
    style G fill:#e1f5fe
    style H fill:#f3e5f5
    style J fill:#e8f5e8
```

## 4. 节点生命周期状态管理
```mermaid
stateDiagram-v2
    [*] --> PendingRegistration: 收到注册 Key
    
    PendingRegistration --> RegisteringWithHeadscale: 调用 headscale 注册命令
    RegisteringWithHeadscale --> RegistrationFailed: 注册失败
    RegisteringWithHeadscale --> DeviceTypeCheck: 注册成功
    
    RegistrationFailed --> [*]: 返回错误信息
    
    DeviceTypeCheck --> AndroidDevice: 检测为 Android
    DeviceTypeCheck --> iOSDevice: 检测为 iOS
    
    iOSDevice --> IgnoredDevice: 不加入缓存
    IgnoredDevice --> [*]: 记录日志并忽略
    
    AndroidDevice --> InitialStatusCheck: 检查初始状态
    InitialStatusCheck --> OnlineAndCached: 设备在线
    InitialStatusCheck --> OfflineRegistered: 设备离线
    
    OfflineRegistered --> OnlineAndCached: 设备上线
    OfflineRegistered --> [*]: 超时未上线，清理记录
    
    OnlineAndCached --> AvailableForProxy: 加入代理池
    OnlineAndCached --> TemporarilyOffline: 检测到离线
    
    AvailableForProxy --> ServingTraffic: 被选中处理请求
    AvailableForProxy --> TemporarilyOffline: 健康检查失败
    
    ServingTraffic --> AvailableForProxy: 请求处理完成
    ServingTraffic --> TemporarilyOffline: 服务过程中离线
    
    TemporarilyOffline --> AvailableForProxy: 重新上线
    TemporarilyOffline --> PermanentlyOffline: 长时间离线
    
    PermanentlyOffline --> RemovedFromCache: 从缓存中清除
    RemovedFromCache --> [*]: 完全移除
    
    note right of OnlineAndCached
        节点信息包含:
        - 节点 ID
        - IP 地址
        - 端口号
        - 设备类型
        - 注册时间
        - 最后活跃时间
        - 健康状态
    end note
```

## 5. Docker 容器部署架构
```mermaid

graph TB
    subgraph "Docker Host"
        subgraph "Frontend Network"
            A[tailscale-proxy<br/>Go 转发服务]
            B[headscale<br/>控制平面]
            C[tailscale<br/>数据平面]
            D[derper<br/>DERP 中继]
            E[headplane<br/>Web 管理界面]
        end
        
        subgraph "数据卷挂载"
            F[headscale-data/]
            G[tailscale-sock/]
            H[config/]
            I[proxy-logs/]
        end
        
        subgraph "端口映射"
            J[8081:8081 HTTP 代理]
            K[1080:1080 SOCKS5 代理]
            L[9091:9091 管理 API]
            M[50443:50443 Headscale gRPC]
            N[3478:3478/udp STUN]
            O[3000:3000 Web UI]
        end
    end
    
    subgraph "外部客户端"
        P[HTTP/HTTPS 客户端]
        Q[SOCKS5 客户端]
        R[管理员]
        S[Web 浏览器]
    end
    
    subgraph "Android 设备网络"
        T[Android 节点 1]
        U[Android 节点 2]
        V[Android 节点 N]
    end
    
    %% 网络连接关系
    A --> B
    A --> C
    A --> D
    B --> C
    C --> D
    
    %% 数据卷关系
    A -.-> F
    A -.-> G
    A -.-> H
    A -.-> I
    B -.-> F
    B -.-> H
    C -.-> G
    
    %% 端口映射关系
    A -.-> J
    A -.-> K
    A -.-> L
    B -.-> M
    D -.-> N
    E -.-> O
    
    %% 外部访问关系
    P --> J
    Q --> K
    R --> L
    S --> O
    
    %% 代理转发关系
    A --> T
    A --> U
    A --> V
    
    style A fill:#e1f5fe
    style B fill:#f3e5f5
    style C fill:#fff3e0
    style D fill:#e8f5e8
    style E fill:#fce4ec
```

## 6. 项目目录结构
```plaintext 
tailscale-go-proxy/
├── main.go                        # 应用程序入口
├── go.mod                         # Go 模块
├── go.sum                         # 依赖锁定
├── Dockerfile                     # Docker 构建文件
├── config.yaml                    # 配置文件
├── README.md                      # 项目说明
│
├── internal/
│   ├── config/                    # 配置管理
│   │   └── config.go
│   ├── headscale/                 # Headscale 客户端
│   │   └── client.go
│   ├── cache/                     # 节点缓存
│   │   └── cache.go
│   ├── proxy/                     # 代理服务
│   │   ├── http.go                # HTTP 代理
│   │   └── socks5.go              # SOCKS5 代理
│   └── register/                  # 节点注册
│       └── register.go
│
└── docker-compose.yml             # 更新现有的 compose 文件
```


## 需要用到的技术

### Go 依赖包：
1. **github.com/gin-gonic/gin** - HTTP 框架
2. **github.com/armon/go-socks5** - SOCKS5 代理实现
3. **google.golang.org/grpc** - gRPC 客户端（连接 headscale）
4. **gopkg.in/yaml.v3** - YAML 配置解析
5. **net/http/httputil** - HTTP 反向代理（Go 标准库）

### 核心功能模块：
1. **HTTP API 服务器** - 提供节点注册接口
2. **Headscale 客户端** - 调用 headscale 的 gRPC/HTTP API
3. **内存缓存** - 存储 Android 节点信息
4. **定时任务** - 每 5s 更新缓存，每 10s 检查在线状态
5. **HTTP 代理服务器** - 转发 HTTP/HTTPS 请求
6. **SOCKS5 代理服务器** - 转发 SOCKS5 请求
7. **设备过滤器** - 识别并过滤 Android 设备

### Docker 集成：
- 在现有 docker-compose.yml 中新增 tailscale-go-proxy 服务
- 挂载 tailscale socket 和 headscale 数据目录
- 暴露 HTTP 代理端口(8081)、SOCKS5 端口(1080)、管理 API 端口(9091)

### 关键 API：
- `POST /register` - 节点注册接口
- `GET /nodes` - 查看缓存节点
- HTTP 代理监听 8081 端口
- SOCKS5 代理监听 1080 端口
- SOCKS5 代理监听 8002 端口

### 代理方式 最终效果
工作原理：

无认证访问：curl -x http://localhost:8081 https://example.com → 使用默认的负载均衡，随机选择一个 Android 节点
带认证访问：curl -x http://key:D5D0R2gwvodpIKhEyZ4lrFVO@localhost:8081 https://example.com → 直接路由到 key 对应的特定节点
  ```
  # 带认证 - 指定节点
curl -x http://D5D0R2gwvodpIKhEyZ4lrFVO:D5D0R2gwvodpIKhEyZ4lrFVO@localhost:8081 https://example.com

# SOCKS5 也支持认证
curl --socks5 D5D0R2gwvodpIKhEyZ4lrFVO:D5D0R2gwvodpIKhEyZ4lrFVO@localhost:1080 https://example.com
  ```
这样就能实现基于 key 的精确节点路由，同时保持向后兼容。

> 代理认证仅支持标准 URL 认证（key:key@host:port），用户名和密码都为 key。