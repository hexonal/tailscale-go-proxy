---
description: 
globs: 
alwaysApply: false
---
# Go 包设计与项目结构 (v1.1)

本规则涵盖了 Go 项目中包的设计原则、依赖管理以及推荐的项目结构，旨在实现高内聚、低耦合、清晰的模块划分，提升代码的可维护性、可测试性和可读性。

## 包设计与依赖管理

### 1. 高内聚 (High Cohesion)
*   **定义**: 包内的代码应该专注于单一的职责或领域。相关的功能、类型以及它们的主要操作应放在同一个包中。
*   **目的**: 提高代码的可读性、可维护性和可重用性。职责清晰的包更容易理解和修改，且不容易影响到其他不相关的部分。
*   **示例**:
    *   `net/http` 包专注于 HTTP 协议的实现。
    *   一个 `user` 包可能包含 `User` 类型定义、用户创建、查询、更新等相关操作。
*   **反模式**:
    *   避免创建过于宽泛的"工具"包（如 `utils`, `common`, `helpers`），这些包往往容易变成各种不相关功能的堆砌，破坏内聚性。应根据功能领域细分。
    *   一个包混合了多种不相关的职责，例如同时处理用户认证、产品管理和订单处理。
*   **AI 指导**:
    *   分析函数或类型的移动/创建请求时，评估其是否与目标包的核心职责一致。
    *   提问："这个新功能/类型是服务于这个包的主要目的，还是一个独立的功能点？"
    *   如果一个包变得过于庞大且职责开始模糊，建议进行拆分。

### 2. 低耦合 (Low Coupling)
*   **定义**: 包之间应尽量减少直接依赖。一个包的变更应尽可能少地影响到其他包。避免循环依赖。
*   **目的**: 提高系统的模块化程度，使得各模块可以独立开发、测试和演进。降低修改代码时引入问题的风险。
*   **实践**:
    *   **接口优先**: 使用接口 (`interface{}`) 来定义协约，实现方依赖具体类型，调用方依赖接口。这符合依赖倒置原则（Dependency Inversion Principle）。
        *   示例：`service` 层定义一个 `UserRepository` 接口，`repository` 层提供具体实现，`service` 层通过该接口与 `repository` 交互，而不是直接依赖具体的数据库实现。
    *   **减少公开 API**: 只导出包外部确实需要的类型、函数和变量。
    *   **避免全局状态**: 全局变量和单例会增加包之间的隐式耦合。
    *   **事件驱动 (可选)**: 对于需要极低耦合的场景，可以考虑使用事件驱动架构。
*   **AI 指导**:
    *   在添加导入语句时，检查是否引入了不必要的依赖。
    *   检查是否存在循环依赖的风险，并提出警告。
    *   建议使用接口进行解耦，特别是对于不同层次（如 service 和 repository）或不同领域模块之间的交互。
    *   检查是否直接实例化了其他包的具体类型，而该场景更适合使用接口。

### 3. 包命名 (Package Naming)
*   **规则**:
    *   使用简短、有意义、小写的单个词作为包名。
    *   包名应清晰地反映其内容和用途。例如，`http`, `json`, `user`。
    *   避免使用下划线 (`_`) 或混合大小写 (camelCase)。
    *   避免使用过于通用的名称，如 `util`, `common`, `lib`, `helper`。如果确实需要共享代码，应根据其具体功能命名，如 `strutil` (字符串工具), `httputil` (HTTP 工具)。
    *   标准库的包名是很好的参考。
*   **导入路径与包名**: 通常，包的导入路径的最后一部分与其包名相同。
    *   例如，包 `github.com/example/project/internal/auth` 的包声明应为 `package auth`。
*   **AI 指导**:
    *   检查新建或重命名的包名是否符合上述约定。
    *   对于不符合规范的包名提出修改建议。

### 4. 错误处理 (Error Handling)
*   **规则**:
    *   错误是值 (Errors are values)。函数或方法在可能失败时，应返回一个 `error` 类型作为其最后一个返回值。
    *   使用 `fmt.Errorf` 或 `errors.New` 创建错误。通过 `fmt.Errorf` 使用 `%w` 动词来包装错误，以保留原始错误的上下文，便于调试。
    *   对于需要特定错误处理逻辑的场景，可以定义自定义错误类型（实现 `error` 接口）或哨兵错误 (sentinel errors, 例如 `io.EOF`)。
    *   避免在库代码中使用 `panic`，除非是不可恢复的程序错误（例如，初始化失败）。应用程序的 `main` 包或 HTTP 处理器顶层可以适当地使用 `recover` 来处理 `panic`。
*   **AI 指导**:
    *   检查可以失败的函数是否返回了 `error`。
    *   建议在错误信息中添加上下文（例如，操作名称、参数值）。
    *   当检测到忽略错误返回值的代码时，进行提示。

### 5. 入口点 (`main` 包)
*   **职责**: `main` 包应尽可能小而简单，其主要职责是：
    *   解析命令行参数和环境变量。
    *   加载配置。
    *   设置日志。
    *   初始化依赖项（如数据库连接、消息队列生产者/消费者等）。
    *   组装和启动应用程序的核心组件（例如，启动 HTTP 服务器、运行后台任务）。
    *   将实际的业务逻辑委托给 `internal` 或 `pkg` 中的其他包。
*   **AI 指导**:
    *   如果 `main.go` 文件包含大量业务逻辑代码，建议用户进行重构，将逻辑拆分到 `internal` 下的 `service`, `handler` 等包中。
    *   确保 `main` 包主要负责程序的"组装"和"启动"。

## 项目结构 (Project Layout)

推荐遵循一个清晰、可扩展的项目结构。以下结构是 Go 社区广泛采用并推荐的，但可以根据项目规模和需求进行调整。

*   **`/cmd`**:
    *   **用途**: 存放项目中的可执行应用程序的入口点 (main 包)。
    *   **结构**: 每个子目录通常对应一个可执行文件，包含一个 `main.go` 文件。例如: `cmd/my-api-server/main.go`, `cmd/my-cli-tool/main.go`。
    *   **AI 指导**: 创建新的可执行应用时，建议在此目录下创建对应的子目录。

*   **`/internal`**:
    *   **用途**: 存放项目私有的应用和库代码。Go 编译器会确保 `internal` 目录下的包不能被项目外部的其他模块导入。这是放置大部分业务逻辑、不想暴露给外部使用的共享库的推荐位置。
    *   **子目录示例**:
        *   **`/internal/app`**: (可选) 可用于存放特定应用程序（对应于 `/cmd` 下的某个应用）的引导和编排代码，如果这些代码不适合放在 `service` 或 `handler` 中。
        *   **`/internal/handler`** (或 `controller`, `api/handler`): 负责处理外部请求（如 HTTP, gRPC），进行参数校验、调用 `service` 层，并格式化和返回响应。**不应包含核心业务逻辑**。
        *   **`/internal/service`** (或 `usecase`, `biz`): 包含核心业务逻辑、领域规则和流程编排。协调 `repository` 层和其他服务。通常不直接依赖于具体的传输层 (e.g., HTTP) 或数据库实现，而是依赖于接口。
        *   **`/internal/repository`** (或 `dao`, `store`, `dal`): 数据访问层，负责与数据存储（数据库、缓存、外部 API 等）进行交互。封装数据持久化和检索的细节，向上层（`service`）暴露接口。
        *   **`/internal/models`** (或 `domain`, `entity`): 定义核心业务对象、数据结构。这些模型被 `service` 和 `repository` 使用。
            *   **注意**: 为保持领域模型的纯净性，避免在此处直接使用 ORM 标签或特定数据库的注解。如果需要，可以在 `repository` 内部定义私有的数据传输对象 (DTO) 或数据库模型进行转换。
        *   **`/internal/middleware`**: (可选) 存放 HTTP 中间件 (如日志、认证、CORS、限流等)。
        *   **`/internal/config`**: (可选) 存放配置加载和管理相关的代码。
    *   **AI 指导**:
        *   创建业务逻辑、数据访问、模型、配置或中间件时，建议放在 `internal` 下相应的子目录中。
        *   如果发现业务逻辑散落在 `handler` 或 `main` 包中，建议将其迁移到 `service` 包。

*   **`/pkg`**:
    *   **用途**: 存放可以被外部应用安全导入的库代码。如果你的项目旨在作为库供其他项目使用，那么这些公共代码应放在这里。
    *   **注意**: 如果不确定是否需要将代码作为公共库暴露，优先将其放在 `/internal`。将代码从 `internal` 移到 `pkg` 比反过来更容易。如果项目仅为内部使用，则可能不需要此目录。
    *   **AI 指导**: 当用户意图创建可被其他独立项目复用的 Go 模块时，建议使用此目录。

*   **`/api`**:
    *   **用途**: 存放 API 契约文件。例如：
        *   OpenAPI/Swagger 规范 (`.yaml`, `.json`)
        *   gRPC 定义 (`.proto`) 文件及生成的 Go 代码
        *   GraphQL schema (`.graphql`)
    *   **AI 指导**: 当项目需要定义或提供外部 API 时，建议在此目录管理 API 定义文件。

*   **`/configs`**: (或 `/config`)
    *   **用途**: 存放配置文件模板或默认配置 (e.g., `config.example.yaml`, `defaults.json`)。
    *   **注意**: 实际的配置文件（尤其是包含敏感信息的）不应提交到版本库，而应通过环境变量、Vault 等安全方式管理，或在部署时注入。
    *   **AI 指导**: 为项目初始化配置文件时，可建议在此创建模板。

*   **`/scripts`**:
    *   **用途**: 存放用于项目自动化任务的辅助脚本。例如：构建、部署、代码生成、数据库迁移、测试辅助等。可以是 shell 脚本 (`.sh`), Makefile, Python 脚本等。
    *   **AI 指导**: 当需要执行项目相关的重复性任务时，建议将其脚本化并存放在此。

*   **`/web`**: (可选, 或 `/ui`, `/static`, `/public`)
    *   **用途**: 存放 Web 前端相关的静态资源 (HTML, CSS, JavaScript, 图片等) 或前端单页应用 (SPA) 的构建产物。如果项目包含一个由 Go 后端提供服务的前端界面，此目录会很有用。
    *   **AI 指导**: 如果项目包含 Web UI 组件，建议使用此目录组织前端资源。

*   **`/build`**: (可选)
    *   **用途**: 存放打包和持续集成 (CI) 相关的文件。例如：
        *   `Dockerfile`
        *   CI/CD 配置文件 (e.g., `.gitlab-ci.yml`, `Jenkinsfile`, GitHub Actions workflows under `.github/workflows`)
        *   打包脚本或配置
    *   **AI 指导**: 在设置容器化或 CI/CD 流程时，建议将相关配置文件放在此。

*   **`/test`**: (可选)
    *   **用途**: 存放额外的测试文件和辅助工具，特别是集成测试、端到端测试 (E2E) 或项目范围的测试数据/工具。
    *   **注意**: 单元测试 (`_test.go` 文件) 通常与被测试的包放在同一个目录下。此 `/test` 目录用于存放那些不适合放在具体包内的测试相关内容。
    *   **AI 指导**: 对于复杂的测试场景或共享的测试基础设施，建议使用此目录。

*   **`/docs`**: (可选)
    *   **用途**: 存放项目的设计文档、用户手册、架构图、API 文档（如果不是自动生成或托管在其他地方）等。
    *   **AI 指导**: 鼓励用户编写和维护项目文档，并将其存放在此。

*   **`/vendor`**:
    *   **用途**: Go 模块机制使用 `go mod vendor` 命令会将项目的依赖项复制到此目录。
    *   **注意**: 通常不需要手动修改此目录。是否将其提交到版本库取决于团队策略（例如，为了在无网络访问的环境中进行确定性构建）。默认情况下，使用 Go Modules 时可以不提交 `vendor` 目录。

### 项目结构总览原则:
*   **清晰职责 (Clear Separation of Concerns)**: 每个包和目录都应有明确的职责。
*   **模块化 (Modularity)**: 组件应尽可能独立，易于替换或修改。
*   **可测试性 (Testability)**: 结构应便于编写单元测试、集成测试和端到端测试。
*   **可维护性 (Maintainability)**: 清晰的结构使代码更易于理解、排错和迭代。
*   **可读性 (Readability)**: 逻辑清晰，命名规范，易于新成员上手。
*   **标准优先 (Standard over Custom)**: 尽可能遵循社区公认的标准结构和约定，减少不必要的"惊喜"。
*   **演进性 (Evolvability)**: 结构应能灵活适应项目的增长和需求变更。

### AI 综合指导 (Project Structure):
*   当用户需要创建新功能或模块时，根据其类型（例如：新的 API 端点、核心业务逻辑、数据访问层、可共享的工具库、配置文件、文档等），主动建议在项目结构中合适的位置创建相应的包或文件。
*   如果检测到代码放置不当（例如，在 `handler` 中实现了复杂的业务逻辑，或在 `main` 包中直接操作数据库），应建议用户将其重构并移动到更合适的层（例如，将业务逻辑移至 `service`，数据库操作移至 `repository`）。
*   对于新项目初始化，可以根据用户描述的项目类型（如 API 服务、CLI 工具、库），推荐一个基础的目录结构。

