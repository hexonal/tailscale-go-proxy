---
description: 
globs: 
alwaysApply: true
---
# Go 代码注释规范 (v1.2)

本文档旨在提供 Go 语言代码注释的统一规范和最佳实践，以提高代码的可读性、可维护性，并确保 `godoc` 等工具能正确生成文档。

## 1. 注释基本原则

*   **解释"为什么"和"是什么"，而非"怎么做"**: 代码本身应该清晰地表达其执行逻辑（"怎么做"）。注释应该聚焦于解释代码背后的原因、目的、业务规则或重要决策。
    *   **好例子**: `// 根据用户等级调整折扣率，因为 VIP 用户享有额外优惠。`
    *   **坏例子**: `// 将变量 i 增加 1。` (代码 `i++` 已经很清晰)
*   **保持更新**: 注释必须与代码同步。代码变更后，相关的注释也必须立即更新。过时的注释比没有注释更误导人。
*   **简洁明了**: 注释应尽可能简短，避免不必要的冗余信息。使用清晰、准确的语言。
*   **英文优先 (推荐)**: 尽管项目内部可能使用其他语言交流，但公开 API 和核心库的注释推荐使用英文，以方便更广泛的开发者社区理解和贡献。对于内部项目，团队可以统一规定注释语言。
*   **完整句子与标点**: 文档注释（尤其是包和公共 API 注释）应使用完整的句子，并以恰当的标点符号结尾。
*   **优先使用中文**: 项目内部应统一使用中文编写注释，以方便团队成员理解和维护。对于需要对外提供（如开源库）或与国际团队协作的场景，可考虑提供英文注释或多语言支持。

## 2. 文档注释 (Godoc)

Go 语言通过 `godoc` 工具从源码中的特定注释提取信息以生成 HTML 文档。因此，注释的结构和内容对生成的文档质量有直接影响。

### 2.1. 包注释 (Package Comments)
*   **要求**: 每个包（除了 `main` 包的某些特殊情况外，也推荐有）都必须在 `package` 声明语句的正上方提供包注释，中间不应有空行。
*   **格式与内容**: 包注释应以 `// Package <包名> ...` 开始 (对于单行注释) 或 `/*
Package <包名> ...
*/` (对于多行注释)。它应概括描述包的功能、主要用途及其提供的核心能力。
    *   应避免在包注释中包含具体的实现细节，除非这些细节对于理解包的公共API至关重要。
    *   如果包非常简单，一句话的摘要可能就足够了。对于复杂的包，可以分段描述其主要功能组件和用途，段落之间用空行分隔。
    ```go
    // Package log提供了标准化的日志记录功能，支持不同的日志级别和输出格式。
    package log
    ```
    ```go
    /*
    Package http实现了 HTTP 客户端和服务器功能。

    本包提供了易于使用的 API 来发起 HTTP 请求，并能方便地构建 HTTP 服务器。
    它支持 GET, POST, HEAD, PUT, DELETE 等多种请求方法，
    并提供了对 HTTPS 的内建支持以及 Cookie 管理。
    */
    package http
    ```

### 2.2. 公共 API 注释 (Exported Identifiers)
*   **要求**: 所有导出的（首字母大写的）标识符——包括类型 (struct, interface, etc.)、函数、方法、常量和变量——都必须有文档注释。注释的目的是为了让调用者无需阅读源码就能理解如何使用该 API。
*   **格式与内容**: 注释紧邻声明之上，不留空行。
    *   **以标识符名称开头**: 注释的第一句话应以被注释的标识符名称开头，后跟对其功能或用途的描述。
    *   **类型 (Types)**: 解释类型的含义、用途及其关键字段。
        *   **结构体 (Structs)**: 对于导出的结构体字段，如果其用途不通过名称自明，也应提供简短注释。这些注释通常跟在字段声明的同一行。
            ```go
            // User 代表系统中的一个认证用户实体。
            type User struct {
                ID        string // 用户的唯一标识符，通常为 UUID。
                Email     string // 用户的电子邮箱地址，用于登录和通知。
                IsActive  bool   // 标记用户账户是否激活，未激活用户无法登录。
                CreatedAt time.Time // 用户记录的创建时间。
            }
            ```
        *   **接口 (Interfaces)**: 注释应描述接口的契约以及每个方法期望的行为。
            ```go
            // DataStore 定义了持久化和检索数据的基本操作。
            // 实现者需要确保操作的原子性和错误处理的正确性。
            type DataStore interface {
                // Get 根据提供的键检索数据。
                // 如果键不存在，应返回 ErrNotFound 类型的错误。
                Get(key string) ([]byte, error)
                // Set 将数据与指定的键关联存储。
                // 如果存储失败，应返回相应的错误。
                Set(key string, data []byte) error
            }
            ```
    *   **函数与方法 (Functions & Methods)**: 描述其功能、行为、参数（名称和用途）、返回值（特别是 `error` 类型，以及多个命名返回值的含义）。明确指出重要的前置条件、后置条件、副作用、并发安全性等。
        *   如果函数有重要的性能特征（例如，它是一个高开销操作，或者有特定的时间复杂度），可以在注释中提及。
        *   对于可能返回 `nil` 指针或空集合（如 slice, map）的情况，如果这代表特定含义（而不仅仅是"无结果"），应予以说明。
        *   对于可变参数函数，说明可变参数的预期类型和用途。
        ```go
        // Authenticate 尝试根据提供的用户名和密码对用户进行身份验证。
        // 如果验证成功，返回一个 User 对象和 nil error。
        // 如果验证失败（例如，密码错误或用户不存在），返回 nil User 和具体的错误信息。
        // 此函数是并发安全的。
        func Authenticate(username, password string) (*User, error) {
            // ... 实现细节 ...
        }

        // UpdateEmail 更新用户的电子邮箱地址。
        // newEmail 参数不能为空。如果更新成功，返回 nil error。
        // 此方法会产生一个审计日志条目。
        func (u *User) UpdateEmail(newEmail string) error {
            // ... 实现细节 ...
        }

        // BatchProcessUsers 以批处理方式处理用户列表，对每个用户应用指定的处理函数。
        // users 是待处理的用户切片。
        // processFunc 是一个回调函数，它接收一个 User 指针并返回一个 error。
        // 如果任何一个 processFunc 调用返回错误，整个批处理将停止并返回该错误。
        // 注意：此函数可能会消耗大量内存，具体取决于用户数量。
        func BatchProcessUsers(users []*User, processFunc func(*User) error) error {
            // ...
        }
        ```
    *   **常量与变量 (Constants & Variables)**: 解释其含义、用途和为何使用该特定值（如果适用）。
        *   对于使用 `iota` 定义的一组常量，可以在常量组的声明上方提供一个总体注释，并在必要时为个别常量（如果其含义不明显）提供单独注释。
        ```go
        // MaxConnections 定义了服务器允许的最大并发连接数。
        // 此值基于当前系统资源和预期的负载进行设定。
        const MaxConnections = 1000

        // ErrUserNotFound 表示在查找用户时未找到指定的用户。
        // 调用者可以使用 errors.Is(err, ErrUserNotFound) 来检查此错误类型。
        var ErrUserNotFound = errors.New("用户未找到")

        // LogLevel 定义了日志记录的级别。
        type LogLevel int
        const (
            LevelDebug LogLevel = iota // LevelDebug 级别，用于详细的调试信息。
            LevelInfo                  // LevelInfo 级别，用于常规操作信息。
            LevelWarn                  // LevelWarn 级别，用于警告潜在问题。
            LevelError                 // LevelError 级别，用于可恢复的错误。
        )
        ```

## 3. 实现注释 (Implementation Comments)

实现注释用于解释非导出代码或导出代码内部的复杂、晦涩或关键逻辑。

*   **目的**: 澄清代码意图、解释算法选择、高亮潜在问题或标注重要上下文。
*   **时机**:
    *   当代码逻辑不直观，或其正确性依赖于某些不明显的假设时。
    *   当代码包含重要的业务规则、复杂的算法或性能优化技巧时。
    *   解释为何选择某种特定算法或数据结构，尤其是在有多种看似合理的选择时。
    *   标记代码中依赖于特定外部系统行为或假设的部分。
    *   解释复杂的正则表达式模式或不直观的位操作。
*   **避免过度注释**:
    *   不要为每一行代码都编写注释，特别是当代码本身逻辑清晰易懂时。
    *   避免简单地将代码"翻译"成自然语言或注释语言的基本语法。
    *   如果一段代码难以理解以至于需要大量注释，首先应该考虑是否可以通过重构代码使其更清晰。
    ```go
    // 使用快速排序算法对数据进行排序，以优化大规模数据集的处理性能。
    // 对于小数据集，插入排序可能更快，但这里预期处理大数据。
    sort.Slice(data, func(i, j int) bool {
        return data[i] < data[j]
    })
    ```

## 4. 特殊标记注释

*   **`// TODO:`**: 标记待完成的任务、未来需要改进的功能或已知的不足之处。
    *   **格式建议**: `// TODO(责任人/日期/IssueID): 清晰描述待办事项。`
    *   **示例**: `// TODO(张三/2023-12-31): 重构此部分以支持插件化架构 (参见 Issue #42)。`
    *   这些标记应视为临时的，目标是最终解决它们。团队应定期审查和清理这些标记。
    *   避免使用 `TODO` 来记录遥不可及的愿望或定义不清晰的非具体问题。
*   **`// FIXME:`**: 标记已知的 Bug 或需要修正的错误代码。
    *   **格式建议**: `// FIXME(责任人/日期/IssueID): 描述问题、可能的原因以及修复建议。`
    *   **示例**: `// FIXME(李四): 此处并发访问共享映射 ` + "`userCache`" + ` 未加锁，可能导致竞态条件。`
    *   与 `TODO` 类似，`FIXME` 也应被积极跟踪和解决。
*   **`// NOTE:`**: 用于强调某个重要信息、解释一个不直观的设计决策或提醒注意特定上下文。
    *   **示例**: `// NOTE: 此处的超时时间设置对下游服务的稳定性至关重要，修改时需谨慎评估。`
*   **`// Deprecated:`**: (官方推荐) 对于导出的 API，如果它已废弃，应在其文档注释中添加以 `Deprecated:` 开头的段落，说明废弃原因以及推荐使用的替代 API。
    *   在注释中明确指出废弃的版本和计划移除的版本（如果已知）。
    *   如果可能，提供迁移到新 API 的代码示例或相关文档链接。
    ```go
    // OldFunction 做一些旧的事情。
    // Deprecated: OldFunction 自 v1.5.0 起已废弃，并计划在 v2.0.0 版本中移除。
    // 请改用 NewFunction，它提供了更优的性能和更丰富的功能。
    // 迁移指南参见：[链接到迁移文档]
    func OldFunction() {}
    ```

## 5. 注释风格与格式

*   **行注释空格**: 标准行注释 `//` 后应跟一个空格，再写注释内容 (例如: `// 这是一个中文注释。`)。
    *   例外：`//go:`, `///` 等特殊用途的注释标记，它们有自己的格式约定。
*   **块注释**: `/* ... */` 形式的块注释较少用于 `godoc` 文档（包注释除外），但可用于实现注释中较长的解释性段落或临时注释掉大段代码块。对于 `godoc`，推荐为每一行都使用 `//`。
*   **避免装饰性注释**: 如用大量星号 `*` 或其他字符组成的边框来"美化"注释块，这会增加维护成本且无实际价值，应避免使用。
*   **注释与代码的对齐**:
    *   实现注释（多行注释）通常放在它们所描述的代码块的上方，并与该代码块的缩进级别相同。
    *   行尾注释应与代码逻辑部分至少隔开一个空格，并尽量将多行的行尾注释垂直对齐以提高可读性。
*   **`godoc` 中的格式化与链接**:
    *   **简单格式化**: `godoc` 将注释中的空行视为空白行，有助于分隔段落。通过将文本块整体缩进（通常比周围的注释文本多一层缩进，例如，前面加一个制表符或多个空格），可以创建预格式化的文本块，适合显示代码示例、表格或 ASCII 图表。
        ```go
        // ProcessData 处理输入数据并返回结果。
        //
        // 处理流程如下：
        //  1. 校验输入参数。
        //  2. 执行核心处理逻辑：
        //     // 这是一个预格式化的代码示例
        //     if err := doSomething(); err != nil {
        //         return err
        //     }
        //  3. 格式化并返回结果。
        func ProcessData(data Input) (Output, error) { /* ... */ }
        ```
    *   **标识符链接**: 在 `godoc` 注释中，可以直接引用同一包内的其他导出标识符（类型、函数、变量等），`godoc` 会自动为它们生成链接。对于其他包中的标识符，可以使用其完整的导入路径后跟点号和标识符名称，例如 `net/http.Client` 或 `io.Reader`，`godoc` 也会尝试为其生成链接。
        ```go
        // NewService 创建一个新的 Service 实例。
        // 它依赖于一个符合 io.Reader 接口的配置源。
        // 返回的 *Service 可以用于执行具体操作。
        func NewService(config io.Reader) (*Service, error) { /* ... */ }
        ```

## 6. 编译器指令与构建约束

Go 语言使用特殊格式的注释作为编译器指令或构建约束，它们不是传统意义上供人阅读的代码注释，而是供工具链使用的元数据。

*   **编译器指令**: 例如 `//go:noescape`, `//go:linkname`, `//go:embed`, `//go:generate`。它们指示编译器执行特定操作。
*   **构建约束 (Build Tags)**: 例如 `//go:build linux && amd64` 或旧格式 `// +build linux,amd64`。它们控制哪些源文件在构建时被包含。
*   **注意**: 这些指令的格式非常严格，必须遵循官方文档。AI 助手应特别注意不要将这些指令当作普通注释来处理或建议修改其内容（除非用户明确意图修改指令本身）。

## 7. AI 指导 (Code Commenting)

*   **检查缺失的文档注释**:
    *   当创建或修改导出的包、类型、函数、方法、常量或变量时，如果缺少符合规范的文档注释，应主动提示补充，并可给出初步的注释建议框架 (例如，以标识符名称开头的句子，并提示说明参数和返回值)。
    *   对于结构体中未注释的导出字段，提示添加说明其用途。
    *   对未提供包注释（或不符合格式）的非 `main` 包进行提醒。
*   **评估注释质量与内容**:
    *   识别仅重复代码逻辑（"怎么做"）的注释，并建议用户阐述其"为什么"或"是什么"，或解释其设计选择和业务背景。
    *   当函数/方法签名（参数、返回值、接收者等）发生变更时，提醒用户检查并更新其文档注释以保持同步。
    *   对于模糊、不完整（如未解释所有参数或关键返回值）或可能引起误解的注释，建议用户进行澄清和补充。
    *   如果注释中提到了具体的版本号、日期或其他可能随时间变化的信息，当这些信息可能过时时，提醒用户检查更新。
    *   （高级）尝试检查注释描述的预期行为是否与函数/方法的实际行为（通过代码分析初步推断）一致，如果不一致则提示。
*   **TODO/FIXME/Deprecated 跟踪与建议**:
    *   定期提醒用户检查代码库中的 `TODO` 和 `FIXME` 注释，确保它们得到及时处理、更新状态或移除（如果已解决）。
    *   当检测到可能适合标记为 `Deprecated` 的旧 API 或用法时，可以提出建议，并提示用户说明废弃原因和替代方案。
    *   （高级）如果 `TODO` 或 `FIXME` 关联了 Issue ID，可以尝试链接到对应的工单系统。
*   **推广注释最佳实践**:
    *   当用户编写的注释不符合推荐的风格（如缺少空格、使用了不必要的装饰、句子不完整等）或内容要求时，提供具体的改进建议。
    *   鼓励用户为复杂或关键的内部逻辑添加必要的解释性注释，以提升代码的可维护性。
    *   鼓励使用 `godoc` 的格式化特性（如预格式化文本块、标识符链接）来增强复杂 API 文档的可读性。
    *   当 AI 建议代码重构时，如果重构会影响原有注释的准确性或相关性，应一并提醒用户更新相关注释。
    *   对于编译器指令或构建约束，AI 应能正确识别它们并非普通注释，避免错误地建议修改其格式或内容，除非用户明确表达此意图。
